Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
 Тема роботи: Програмна система для відстеження та управління рухом та розміщенням товарів на складах

Студентка гр. ПЗПІ-21-6          __________________ Тимощенко В. Р.
(підпис)
Керівник роботи 			___________________ ст.викл. Сокорчук І.П.
(підпис) 

Роботу захищено «__»_________2024 р.
з оцінкою _________________________ 

Комісія: 				___________________ доц. Лещинський В.О. 
(підпис)
___________________ доц. Лещинська І.О. 
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 р.



Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6
Навчальна дисципліна Архітектура програмного забезпечення                           


ЗАВДАННЯ
НА ЛАБОРАТОРНІ РОБОТИ СТУДЕНТОВІ

 	Тимощенко Владиславі Русланівні	
⦁	Тема проєкту: Програмна система для відстеження та управління рухом та розміщенням товарів на складах “SmartStock Manager”.                                                                          

⦁	Термін узгодження завдання з лабораторних робіт «1» квітня 2024 р.
⦁	Термін здачі завдання з лабораторних робіт «14» червня 2024 р.
⦁	Вихідні дані до проєкту: оригінальність і неповторність; передбачення            майбутньої монетизації; актуальність проблеми; орієнтованість на масове                      використання; масштабованість; підтримка інтернаціоналізації та локалізації;                 
двомовний інтерфейс (українська та англійська); захист даних; серверна частина, клієнтська частина, мобільний застосунок, IoT або SmartDevice програмний          застосунок; адміністрування системи.                                                                          

⦁	Зміст	звітів з лабораторних робіт	(перелік	питань,	що	належить розробити) аркуш завдання у форматі Vision & Scope; загальна архітектура
системи; будова серверних компонентів; структура бази даних; взаємодія                             програмного забезпечення з IoT або SmartDevice; будова веб-компонентів; будова мобільного застосунку.
⦁	Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): UML діаграма розгортання (Deployment Diagram); UML діаграма прецедентів (Use Case             Diagram); ER-модель даних (діаграми) (Entity–Relationship Model); UML              діаграма компонент (Component Diagram); UML діаграма взаємодії (Interaction   Overview Diagram); UML діаграма діяльності (Activity Diagram).                          

КАЛЕНДАРНИЙ ПЛАН





№	Основні етапи виконання проєкту
в рамках лабораторних робіт	Термін виконання
етапів	Примітка
1	Vision & Scope	19.03.2024	
Виконано
2	Серверна частина (Back-End)	02.04.2024	
Виконано
3	Програмне забезпечення для IoT або SmartDevice пристрою	16.05.2024	
Виконано
4	Клієнтська частина застосунку (Front- End)	30.05.2024	
Виконано
5	Мобільний застосунок	14.06.2024	

Дата видачі теми проєкту «18» березня 2024 р.


Викладач лабораторних робіт	 	доц. Сокорчук І.П.
(підпис)


 Завдання прийняв до виконання
ст.гр. ПЗПІ-21-6	Тимощенко В.Р
(підпис)



РЕФЕРАТ


Анотація до курсової роботи: 87 с., 18 рис., 3 табл., 2 додатки, 5 джерел.
СКЛАДСЬКА ЛОГІСТИКА, УПРАВЛІННЯ ЗАПАСАМИ, RFID-ТЕХНОЛОГІЇ, АВТОМАТИЗОВАНЕ УПРАВЛІННЯ, АНАЛІЗ ПРОДАЖІВ.
Об'єкт дослідження – система для моніторингу та управління переміщенням і розташуванням товарів на складах. Основна мета розробки – створення платформи, яка здатна автоматично відстежувати наявність товарів у складських приміщеннях за допомогою RFID-технологій, а також здійснювати автоматичне замовлення нових партій товарів відповідно до поточного рівня запасів та прогнозованих потреб.
Методи розробки передбачають застосування мікроконтролерів для збору інформації з RFID-міток, що закріплені на товарах, використання Node.js для серверної частини, а також застосування бази даних PostgreSQL для зберігання інформації про стан запасів і історію продажів. Інтерфейс системи реалізовано за допомогою React, що дозволяє відображати в реальному часі місцезнаходження товарів та рівень запасів.
Система надає можливість автоматизовано відстежувати місцезнаходження товарів у складських приміщеннях, визначати необхідність поповнення запасів і автоматично формувати замовлення на нові партії продукції. За рахунок інтеграції з аналітичними модулями, платформа здатна прогнозувати потреби у запасах, базуючись на аналізі попередніх продажів, що дозволяє зменшити ймовірність дефіциту або надлишку товарів.
Ця платформа значно підвищує ефективність управління складськими запасами, зменшуючи ручну роботу та покращуючи точність і швидкість обліку товарів. Вона сприяє оптимізації логістичних процесів і забезпечує своєчасне поповнення товарних запасів на основі фактичного стану складу та прогнозованих потреб, що в результаті підвищує загальну продуктивність та економічну ефективність складської діяльності.























ЗМІСТ

ВСТУП......................................................................................................................6
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ.....................................................................7
1.1 Бізнес-вимоги.....................................................................................................7
  1.1.1 Бізнес можливості........................................................................................7
  1.1.2 Бізнес-цілі та критерії успіху.......................................................................8
  1.1.3 Потреби клієнтів або ринку........................................................................11
  1.1.4 Бізнес-ризики..............................................................................................13
1.2 Концепція рішення..........................................................................................15
  1.2.1 Окреслення концепції................................................................................15
  1.2.2 Головна функціональність.........................................................................16
  1.2.3 Припущення та залежності........................................................................18
1.3 Рамки та обмеження проєкту..........................................................................20
  1.3.1 Обсяг початкового випуску........................................................................20
  1.3.2 Рамки наступних випусків.........................................................................22
  1.3.3 Обмеження та винятки...............................................................................23
1.4 Бізнес-контекст.................................................................................................23
  1.4.1 Профілі зацікавлених сторін......................................................................23
  1.4.2 Пріоритети проекту....................................................................................24
  1.4.3 Робоче середовище.....................................................................................26
2 ПОСТАНОВКА ЗАДАЧІ....................................................................................28
3 ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЕКТУ.............................................30
  3.1 Проектування серверної частини проекту...................................................30
  3.2 Проектування IoT-частини системи.............................................................36
  3.3 Проектування клієнтської частини проекту................................................37
4 РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ.......................................................48
4.1 Архітектура та розробка серверної частини.................................................48
4.1.1 Специфікація REST API..............................................................................49
  4.1.2 API для створення розкладу та його події...............................................58
  4.1.3 API Service для перевірки подій розкладу...............................................58
  4.1.4 API для активації пацієнтом події розкладу............................................60
4.2 Архітектура та розробка IoT частини............................................................61
4.4 Архітектура та розробка web частини...........................................................63
ВИСНОВКИ...........................................................................................................67
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ.....................................................................68
ДОДАТОК А...........................................................................................................69
ДОДАТОК Б...........................................................................................................81


















ВСТУП


Розробка Платформи відстеження та управління рухом та розміщенням товарів на складах зумовлена необхідністю ефективного та точного контролю за запасами у складських приміщеннях. У сучасній логістичній індустрії управління рівнями запасів та їхнім розташуванням є ключовим для оперативної ефективності та задоволення клієнтів. Традиційні ручні методи схильні до помилок та неефективностей, що призводить до проблем, таких як дефіцит товарів, перевантаження складів та труднощі з швидким пошуком предметів.
У відповідь на ці проблеми, платформа має мету забезпечити надійне рішення за допомогою використання передових технологій, таких як RFID мітки та автоматизовані системи управління запасами.
Зростаюча складність управління запасами вимагає більш точного та ефективного контролю, особливо у зв'язку зі збільшенням різноманітності продукції та потребами в різних умовах зберігання. Вимога до реального часу відстеження запасів стає все більш актуальною в умовах зростання електронної комерції та моделі доставки "just-in-time", що забезпечує своєчасне виконання замовлень та ефективне поповнення запасів.
Автоматизовані системи здатні значно знизити витрати на робочу силу, пов'язані з управлінням запасами, мінімізуючи ручне втручання та зменшуючи ймовірність людських помилок. 
Отже, передумови для створення Платформи відстеження та управління рухом та розміщенням товарів на складах полягають у необхідності підвищення точності, ефективності та масштабованості управління запасами шляхом впровадження сучасних технологічних рішень.
⦁	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
⦁	Бізнес-вимоги
⦁	Бізнес можливості


Платформа відстеження та управління рухом та розміщенням товарів на складах надасть унікальні можливості для вирішення низки актуальних проблем у сфері логістики та управління запасами. Зростання електронної комерції, а також підвищені вимоги до швидкості та точності обробки замовлень створюють сприятливе середовище для впровадження інноваційних рішень, таких як дана платформа.
Існуючі ринкові продукти часто обмежені в своїй функціональності, що створює труднощі для компаній, які прагнуть інтегрувати нові технології у свої операційні процеси. Ця платформа відрізняється тим, що пропонує інтеграцію з RFID мітками, які дозволять точно відслідковувати місцезнаходження кожного товару на складі. Це значно полегшить процес інвентаризації та пошуку товарів.
Крім того, платформа буде автоматично замовляти нові товари при низькому рівні запасів та прогнозує кількість товарів, необхідних для замовлення, на основі аналізу продажів. Це допомагає уникнути як дефіциту, так і надлишків запасів, оптимізуючи витрати та підвищуючи ефективність управління складом.
Проаналізуємо ринок та існуючі аналоги:
Ринок логістичних рішень стрімко розвивається, і на ньому з’являється все більше продуктів, орієнтованих на автоматизацію процесів. Однак, більшість з них не забезпечують повного спектру функцій, необхідних для комплексного управління складськими операціями. Наша платформа заповнює цю нішу, пропонуючи всеосяжне рішення, що відповідає сучасним ринковим тенденціям та корпоративним стратегічним напрямкам.
Fishbowl Inventory - це програмне забезпечення для управління запасами, яке забезпечує відстеження товарів та автоматизацію деяких процесів. Однак, воно обмежене у функціоналі та потребує додаткових модулів для повної інтеграції з іншими системами.
Zoho Inventory - ця система пропонує функції управління запасами та замовленнями, але має обмежені можливості для інтеграції з фізичними RFID мітками, і недостатньо автоматизовані процеси поповнення запасів.
NetSuite WMS - потужне рішення для управління складом, яке включає різноманітні функції для оптимізації складських операцій. Проте, висока вартість і складність впровадження можуть бути перешкодою для середніх та малих підприємств.
Проблеми, які наразі не можуть бути вирішені без нашого продукту, включають:
а)	труднощі в точному та швидкому відстеженні місцезнаходження товарів на складі;
б)	високі витрати та час, пов'язані з ручним управлінням запасами;
в)	неможливість точного прогнозування потреб у запасах без аналізу продажів;
д) 	ризик дефіциту або надлишків запасів через неефективне управління;
Впровадження нашої платформи дозволить вирішити актуальні проблеми управління запасами, підвищити ефективність операцій та забезпечити конкурентні переваги на ринку.


⦁	Бізнес-цілі та критерії успіху


Платформа відстеження та управління рухом та розміщенням товарів на складах має на меті досягнення кількох важливих бізнес-цілей, які можна кількісно виміряти. Основні цілі включають підвищення операційної ефективності, зменшення витрат на управління запасами та збільшення задоволеності клієнтів. Планується досягти таких бізнес-цілей:
BO-1: зменшення помилок при обліку запасів до менш ніж 1% протягом першого року використання платформи;
BO-2: зниження середнього часу на пошук товару на складі на 50% протягом перших шести місяців після впровадження системи;
BO-3: зниження витрат на робочу силу, пов'язану з управлінням запасами, на 30% протягом першого року;
BO-4: Збільшення точності прогнозування потреб у поповненні запасів до 95%, що зменшить дефіцит та надлишки запасів на 40% протягом першого року;
BO-5: Підвищення рівня задоволеності клієнтів на 20% через більш точне та швидке виконання замовлень протягом першого року.
Критерії успіху даного проєкту будуть базуватися на досягненні цих бізнес-цілей, а також на дотриманні таких параметрів:
SC-1: успішне впровадження платформи у визначені терміни та відповідно до бюджету. Залучення та навчання персоналу для ефективного використання системи;
SC-2: регулярний моніторинг та аналіз ключових показників ефективності, таких як точність інвентаризації, час пошуку товарів, витрати на управління запасами та рівень задоволеності клієнтів.
SC-3: вихід на нові ринки та залучення нових клієнтів протягом другого року після запуску платформи, що свідчить про її конкурентоспроможність та привабливість;
SC-4: сервіс повинен бути готовий до запуску на ринок до кінця весни 2024 року;
SC-5: сервіс повинен бути рентабельним та конкурентоспроможним. Будуть контролюватися витрати на розробку, запуск та підтримку даного сервісу, а також встановлювати оптимальну ціну за сервіс. Буде проводитися аналіз ринку та конкурентів, а також враховуватися потреби та можливості клієнтів.


1.1.3 Потреби клієнтів або ринку


Дана платформа розробляється для задоволення потреб різних сегментів ринку, включаючи логістичні компанії, роздрібних продавців, виробників та дистриб'юторів. Ці клієнти стикаються з рядом проблем, які не можуть бути ефективно вирішені існуючими системами. Основні потреби клієнтів включають:
а) точне відстеження товарів на складі:
		1) потреба в системі, яка дозволяє точно і швидко визначати місцезнаходження товарів за допомогою QR-кодів або інших міток;
		2) вирішення проблеми з плутаниною та втратами товарів через неправильне розміщення або ручні помилки.
	б) автоматизація поповнення запасів:
		1) необхідність автоматизованого поповнення запасів на основі поточних рівнів та прогнозів продажів;
		2) усунення проблем дефіциту або надлишку товарів шляхом точного прогнозування потреб у запасах.
	в) зменшення витрат на управління запасами:
		1) потреба в скороченні витрат на робочу силу, пов'язану з управлінням запасами;
		2) оптимізація процесів інвентаризації та поповнення запасів для підвищення ефективності.
	г) підвищення ефективності складування:
		1) необхідність швидкого та точного переміщення товарів всередині складу;
		2) зменшення часу на пошук та обробку товарів, що збільшує загальну продуктивність складу.
	д) критичні вимоги до інтерфейсу та продуктивності:
		1) інтуїтивно зрозумілий і зручний користувацький інтерфейс, який мінімізує час на навчання персоналу;
		2) висока продуктивність системи, що забезпечує швидке виконання операцій з великими обсягами даних.


1.1.4	Бізнес Ризики


Даний продукт може зіткнутися з такими викликами та загрозами:
а)	конкуренція на ринку: продукт може мати сильних конкурентів, які пропонують схожі або кращі сервіси для догляду за рослинами за допомогою IoT пристроїв. Це може призвести до зниження попиту на продукт або необхідності знижувати ціну за нього. Для зменшення цього ризику потрібно проводити ретельний аналіз ринку та конкурентів, а також виділяти продукт унікальною цільовою аудиторією, функціональністю та перевагами;
б)	проблеми з термінами: продукт може зазнати затримок у розробці, тестуванні або запуску на ринок через непередбачені обставини, такі як технічні складнощі, нестабільність IoT пристроїв, зміна вимог клієнтів тощо. Це може призвести до втрати конкурентної переваги або незадоволення клієнтів. Для зменшення цього ризику потрібно дотримуватися плану проєкту, який визначає етапи, завдання, ресурси та відповідальних осіб. 
в)	сприйняття користувачами: Даний продукт може не викликати інтересу або довіри серед потенційних клієнтів, які можуть бути незнайомі з IoT технологіями або мати стереотипи щодо їх складності, ненадійності або небезпеки. Це може призвести до низької конверсії або відмови від сервісу. Для зменшення цього ризику потрібно проводити ефективну маркетингову кампанію, яка би демонструвала переваги та простоту використання сервісу, а також надавати безкоштовну пробну версію або гарантію повернення грошей для клієнтів.
д)	проблеми з впровадженням: Даний продукт може зустріти труднощі з встановленням, налаштуванням або інтеграцією з існуючим обладнанням та системами на підприємствах. Це може призвести до поганої якості сервісу, незадоволення клієнтів або втрати даних. Для зменшення цього ризику потрібно розробити продукт таким чином, щоб він був сумісний з різними видами рослин та пристроїв, а також надавати чіткі інструкції, підтримку та обслуговування для наших клієнтів.

⦁	Концепція рішення
⦁	Окреслення концепції


Дана програмна система контролю за рослинами на підприємствах є інноваційним сервісом, спрямованим на оптимізацію догляду за рослинами в приміщеннях підприємств. Ця система буде розроблена для створення комфортного та ефективного робочого середовища, використовуючи сучасні технології Інтернету речей (IoT).
Метою цього проєкту є забезпечення автоматизованого догляду за рослинами, моніторингу їх здоров’я та індивідуального підходу до догляду. Система також надасть користувачам сповіщення та автоматичні дії для підтримки здоров’я рослин.
Ця ідея особливо актуальна для компаній, де великі клумби та різноманітні види рослин створюють особливу атмосферу та сприяють підвищенню екологічної обізнаності співробітників та клієнтів. Система GreenArea допоможе підприємствам підтримувати свої рослини в найкращому стані, забезпечуючи їхнє здоров’я та красу.


⦁	Головна функціональність


Основними характеристиками продукту “ Stock Manager” є:
MF-1: Відстеження товарів за допомогою RFID міток. Платформа дозволить точно і швидко визначати місцезнаходження кожного товару на складі, використовуючи RFID мітки;
MF-2: Автоматичне поповнення запасів. Система автоматично замовлятиме нові товари, коли рівень запасів на складі досягне критичної позначки, на основі прогнозів продажів та поточних рівнів запасів;
MF-3: Аналітика та прогнозування. Система збиратиме та аналізуватиме дані про рух товарів, попит та запаси, що дозволить робити точні прогнози та приймати обґрунтовані рішення;
MF-4: Автоматичне замовлення товарів в реальному часі. Платформа буде надсилати автоматичні запити про критичні рівні запасів.
MF-5: Безпека та контроль доступу. Система забезпечить високий рівень безпеки даних та контроль доступу, дозволяючи налаштовувати різні рівні доступу для користувачів;
Відмінності від конкурентних продуктів:
а) точність та швидкість. Завдяки використанню RFID міток та автоматичному поповненню запасів дана платформа забезпечить високу точність та швидкість обробки складських операцій;
б) прогнозування та аналітика. Система пропонує потужні аналітичні інструменти та можливості прогнозування, що допомагає приймати більш обґрунтовані рішення;
в) інтуїтивний інтерфейс. Платформа матиме зручний та інтуїтивно зрозумілий інтерфейс, що мінімізує час на навчання персоналу та підвищить загальну ефективність роботи;
г) мобільність. Підтримка мобільних пристроїв дозволить працівникам складу виконувати свої задачі без прив’язки до стаціонарних робочих місць, підвищуючи гнучкість та оперативність.



⦁	Припущення та залежності
	

Припущення:
а) система буде використовуватися на складах малого та середнього розміру з різними видами товарів;
б) клієнти матимуть доступ до стабільного з’єднання для забезпечення безперебійної роботи платформи;
в) користувачі мають базові навички роботи з мобільними пристроями та зможуть швидко навчитися користуватися новим програмним забезпеченням;
г) компанії-клієнти будуть готові інвестувати в необхідне обладнання для сканування RFID міток;
ґ) платформа буде розроблена з урахуванням сучасних вимог безпеки та конфіденційності даних, що відповідає нормам і стандартам галузі.
Залежності:
а) технологічні залежності: успіх проекту залежатиме від стабільної роботи використовуваних технологій, таких як системи сканування RFID міток, бази даних, сервери та мобільні додатки. Це включатиме вибір надійних постачальників обладнання та програмного забезпечення;
б) треті сторони та постачальники: проєкт залежить від співпраці з постачальниками обладнання для сканування RFID міток, а також з компаніями, що забезпечують послуги хмарного зберігання даних та обробки інформації;
в) підтримка клієнтів: платформа залежатиме від наявності ефективної системи підтримки клієнтів, яка забезпечить навчання користувачів, оперативну технічну підтримку та своєчасне вирішення проблем;
г) фінансові ресурси: для успішної розробки та впровадження проекту необхідно забезпечити достатнє фінансування на всіх етапах, включаючи розробку, тестування, маркетинг та підтримку.


⦁	 Рамки та обмеження проєкту
⦁	Обсяг початкового випуску 


У першому випуску програмного продукту для управління складом будуть реалізовані наступні основні функції:
а) Серверна частина (Back-End):
⦁	забезпечення зберігання, обробки та передачі даних від сканерів RFID міток та клієнтських додатків;
⦁	реалізація бізнес-логіки для відстеження розташування товарів на складі, обробки замовлень та автоматичного поповнення запасів;
⦁	розробка API для інтеграції з клієнтською та мобільною       частинами;
⦁	реалізація головних функцій, таких як реєстрація, авторизація, керування обліковим записом, налаштування, звітність;
⦁	реалізація рівнів адміністрування: Адміністратор та Користувач та Менеджер складу. Адміністратор буде мати повний доступ до системи, Менеджер складу зможе керувати зареєстрованим на нього складом та товарами в ньому.
б) Клієнтська частина (Front-End):
⦁	розробка веб-додатку, який дозволить користувачам переглядати, аналізувати та керувати даними про розташування товарів на складі, отримувати сповіщення про рівень запасів та автоматичні дії з поповнення запасів;
⦁	забезпечення інтуїтивного та простого інтерфейсу, який буде сумісний з усіма основними браузерами та пристроями;
⦁	реалізація функцій локалізації, які дозволять користувачам вибирати мову веб-додатку;
⦁	інтеграція з API серверної частини для отримання та відправлення даних.
в) Мобільний програмний застосунок:
⦁	розробка мобільного додатку, який надаватиме користувачам ті ж функції, що й веб-додаток, але з можливістю використовувати їх зі свого смартфона;
⦁	забезпечення оптимізованого та зручного інтерфейсу;
⦁	реалізація функцій локалізації, які дозволять користувачам вибирати мову мобільного додатку;
⦁	інтеграція з API серверної частини для отримання та відправлення даних.
г) Інтерфейс сканування RFID міток:
⦁	розробка програмного забезпечення для сканерів RFID міток, які будуть використовуватися для ідентифікації товарів та відстеження їх розташування на складі;
⦁	забезпечення надійності, стабільності та безпеки зв'язку між сканерами та серверною частиною;
д) Бізнес логіка:
⦁	для кожного товару на складі, продукт має створити унікальний ідентифікатор, який буде пов’язаний з RFID міткою, що прикріплена до товару, та з даними про товар, такими як назва, кількість, місце розташування, дата надходження;
⦁	продукт має здійснювати автоматичні дії, такі як замовлення нових товарів при низькому рівні запасів;
⦁	для кожного підприємства, яке користується продуктом, продукт має створити унікальний ідентифікатор, який буде пов’язаний з даними про підприємство, такими як назва, адреса, контакти;
⦁	для кожного підприємства продукт має надавати доступ до веб-додатку та мобільного додатку для всіх співробітників, які мають дозвіл від підприємства.


1.3.2 Рамки наступних випусків


Наступні випуски платформи будуть спрямовані на розширення функціональності та підвищення ефективності системи. Основні рамки майбутніх версій включають:
а) Інтеграція з додатковими сенсорами: У подальших випусках буде додана підтримка інших типів сенсорів, таких як температурні або вологісні датчики. Це дозволить відслідковувати умови зберігання товарів на складі та автоматично повідомляти про відхилення від нормальних параметрів.
б) Покращення прогнозування потреб у запасах: У майбутніх версіях буде впроваджено вдосконалені алгоритми машинного навчання для більш точного прогнозування потреб у запасах. Це допоможе зменшити ймовірність дефіциту або надлишку товарів, враховуючи сезонні коливання попиту та інші фактори.
в) Розширення функцій аналітики: Наступні випуски передбачають додавання розширених функцій аналітики, що дозволять керівникам складу отримувати глибокий аналіз даних щодо ефективності роботи складу, включаючи оптимізацію логістичних процесів та управління ресурсами.
г) Інтеграція з зовнішніми системами: Планується розробка API для інтеграції платформи з зовнішніми системами ERP, CRM та іншими корпоративними програмними рішеннями. Це дозволить забезпечити безперервний потік інформації між різними відділами компанії та підвищити загальну ефективність управління бізнесом.
д) Підтримка багатомовності: Для розширення використання платформи на міжнародних ринках буде додана підтримка кількох мов інтерфейсу. Це дозволить компаніям із різних країн ефективно використовувати систему у своїй діяльності.
е) Мобільний додаток: У майбутньому планується розробка мобільного додатка для відстеження запасів у реальному часі безпосередньо зі смартфонів або планшетів. Це підвищить зручність користування системою та дозволить оперативно реагувати на будь-які зміни.
Кожен із зазначених напрямків розвитку платформи буде реалізовуватись поетапно, з урахуванням зворотного зв’язку від користувачів та змін на ринку логістичних послуг.







⦁	Обмеження та винятки


При розробці та впровадженні платформи для відстеження та управління рухом і розміщенням товарів на складах існує кілька важливих обмежень і винятків, які необхідно врахувати.
Технологічні обмеження: Платформа залежить від наявності на складах RFID-міток та відповідного обладнання для їх зчитування. У випадках, коли використання RFID технологій неможливе або економічно невиправдане, ефективність системи може бути знижена. Крім того, платформа вимагає стабільного Інтернет-з'єднання для забезпечення безперервної роботи та синхронізації даних між сервером і клієнтськими пристроями.
Масштабування: Хоча платформа передбачає можливість розширення, початкова версія орієнтована на середні та великі склади. Для дуже великих складів або компаній з кількома складами, що мають специфічні вимоги, може знадобитися додаткова розробка та адаптація під конкретні умови.
Безпека даних: Оскільки система оперує з великими обсягами даних, включаючи конфіденційну інформацію про товарні запаси, обмеженнями є вимоги до високого рівня захисту даних. Платформа використовує стандартні механізми шифрування для зберігання та передачі даних, проте вразливості можуть виникати при неправильній конфігурації системи або недостатній увазі до безпеки з боку користувачів.
Функціональні обмеження: Поточна версія платформи не передбачає підтримку роботи з товарами, що мають особливі умови зберігання, такі як температурний режим або умови вологості. Такі функції можуть бути додані у майбутніх версіях за потреби.
Юридичні обмеження: Використання RFID технологій та автоматизованих систем управління підлягає національним та міжнародним регуляціям. Деякі функції платформи можуть бути обмежені через законодавчі вимоги або політики приватності, що діють у конкретних регіонах.
Обмеження щодо користувацького інтерфейсу: Поточний дизайн інтерфейсу орієнтований на стандартні настільні комп'ютери та ноутбуки.
Веб-версія платформи може не повністю підтримувати роботу на мобільних пристроях або планшетах без додаткової адаптації.
Ці обмеження та винятки враховуються при плануванні впровадження платформи, і можуть бути усунені або змінені у наступних версіях відповідно до зростаючих вимог і потреб користувачів.


⦁	Бізнес-контекст
⦁	Профілі зацікавлених сторін


Таблиця 1.4.1 – Профілі зацікавлений сторін
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Звичайний користувач	Зручність доступу до інформації про товари та можливість здійснювати замовлення	Позитивне, система спрощує процес вибору та замовлення товарів	Швидкий доступ до актуальних товарів та інформації про їх наявність	Обмежений доступ до внутрішньої інформації складу, відсутність можливості керування товарними запасами
Менеджер складу	Оптимізація процесів управління складом та відстеження товарів	Позитивне, система допомагає ефективніше керувати запасами та покращити логістику	Збільшення ефективності управління товарними запасами, зменшення втрат та оптимізація простору складу	Відсутність можливості доступу до конфіденційної інформації користувачів та фінансових даних
Адміністратор	Загальний контроль над системою, можливість управління користувачами та налаштування платформи	Позитивне, система забезпечує повний контроль та гнучкість у налаштуваннях	Підтримка стабільної роботи платформи, управління ролями користувачів та забезпечення безпеки даних	Відповідальність за збереження даних та безперебійне функціонування платформи





⦁	Пріоритети проєкту


Таблиця 1.4.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Реліз початкової версії запланований на 14.12, оновлення – на 10.01.24	Допустиме відхилення від початкового графіку – до 14 днів	Початкова версія – коригування в межах 5 днів, оновлення – до 7 днів
Функціональність	Початкова версія: основні функції моніторингу та аналізу; оновлення: додавання нових можливостей	Всі визначені функції повинні бути впроваджені відповідно до версій	Для початкової версії має бути реалізовано 70-80% критично важливих функцій
Якість	Продукт повинен відповідати високим стандартам надійності та безпеки	Всі тести на працездатність та безпеку мають бути пройдені	У початковій версії повинні бути успішно пройдені 90-95% тестів, в оновленні – 95-98%
Персонал	Основна команда повинна бути укомплектована до 01.07.2025	Розмір команди не повинен перевищувати одного працівника	Залучення додаткових ресурсів для проєкту неприпустимо
Бюджет	70% коштів виділено на початковий етап, залишок – на оновлення	Загальний бюджет не може бути перевищений	Можливе перевищення витрат до 10% без зміни початкового плану


⦁	– Робоче середовище


Робоче середовище, у якому буде функціонувати система, визначає низку вимог, що впливають на її проєктування та реалізацію. Основні фактори, що слід врахувати:
Дистанційний доступ. Оскільки користувачі можуть проживати в різних регіонах і часових поясах, система має забезпечувати надійний та безперебійний доступ незалежно від місця розташування.
Доступність у будь-який час. Важливо, щоб система була доступною для користувачів цілодобово, оскільки вчасний доступ до інформації є критично важливим для ефективного виконання їхніх обов'язків.
Безпека та конфіденційність. Враховуючи, що система працюватиме з чутливими даними, необхідно забезпечити високий рівень захисту інформації, включаючи контроль доступу та надійне зберігання даних
Для реалізації цієї системи буде використовуватися набір сучасних інструментів та технологій
а) Back-end частина:
		1) NestJS як основний фреймворк для розробки серверної логіки.
		2) PostgreSQL для зберігання даних та забезпечення надійного доступу до них.
б) Front-end частина:
		1) React для побудови динамічного користувацького інтерфейсу.
		2) HTML/CSS для створення та стилізації веб-сторінок.
		3)JavaScript/TypeScript для забезпечення логіки та інтерактивності на стороні клієнта.
в) IoT інтеграція:
		1) C++ для написання програмного забезпечення, що працює з IoT-пристроями та забезпечує збір і передачу даних до системи.
Такий підхід дозволяє створити систему, що відповідає вимогам доступності, надійності та безпеки в сучасному робочому середовищі.








⦁	ПОСТАНОВКА ЗАДАЧІ


В результаті аналізу основної предметної області було сформульовано завдання створити програмну систему для управління складськими запасами, обробки замовлень та підтримки роботи користувачів різних ролей.
База даних має містити інформацію про користувачів (покупців), складські запаси, продукти, транзакції та логістичні операції.
Система має забезпечувати наступний функціонал для різних ролей користувачів:
а)	Користувачі (покупці) отримають можливість:
1)	реєструватися та входити в систему;
2)	переглядати доступні продукти та їхні характеристики;
3)	додавати товари до кошика та оформляти замовлення;
4)	переглядати історію своїх замовлень та статуси їх виконання;
5)	можливість підвищити статус до менеджера та зареєструвати свій склад.
б)	Менеджери складів будуть мати доступ до:
1)	управління інформацією про продукти на складі, включаючи додавання, редагування та видалення товарів;
2)	обробки замовлень від користувачів, зміни їх статусів та відстеження логістики;
3)	управління складськими запасами, включаючи оновлення кількості товарів та контроль їх доступності;
4)	створення звітів про стан запасів та ефективність складських операцій.

в)	Адміністратори зможуть:
1)	управляти всіма користувачами системи, включаючи додавання нових менеджерів складів та контролювання їх прав доступу;
2)	оновлювати системні налаштування та контролювати безпеку даних;
3)	оглядати всі транзакції та складські операції, забезпечуючи цілісність і безперервність роботи системи.
Система повинна забезпечувати стабільний обмін даними між всіма компонентами і підтримувати високу продуктивність навіть при одночасній роботі великої кількості користувачів.
Серверна частина системи буде реалізована на основі NestJS, що забезпечить гнучкість та масштабованість, а клієнтська частина буде створена з використанням React для надання інтуїтивного та швидкого інтерфейсу. Для інтеграції з IoT-пристроями, що використовуються для моніторингу складів, буде застосовано мову C++.












3	ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЕКТУ
3.1	Проектування серверної частини проекту


Перед розробкою серверної частини системи необхідно ретельно визначити всі сутності, які будуть використовуватися для реалізації заданого функціоналу. Для цього слід розробити ER-діаграму (див.рис.3.1), яка відображатиме структуру даних і зв'язки між сутностями. Створення цієї моделі дозволить чітко окреслити взаємодію між елементами системи та уникнути помилок під час подальшого кодування.
В межах цієї ER-моделі (див.рис.3.1 у додатку Б) передбачено наступні сутності та відповідні атрибути для них:
а)	Користувачі (users):
1)	Унікальний ідентифікатор користувача (user_id);
2)	Ім'я користувача (user_name);
3)	Електронна пошта (email);
4)	Пароль (password);
5)	Роль користувача (role_id);
6)	Аватар (avatar);
7)	Дата створення облікового запису (created_at).
б)	Ролі (roles):
1)	Ідентифікатор ролі (role_id);
2)	Назва ролі (role_name).
в)	Складські запаси (inventory):
1)	Унікальний ідентифікатор запису (inventory_id);
2)	Ідентифікатор продукту (product_id);
3)	Ідентифікатор складу (warehouse_id);
4)	Кількість товару на складі (quantity).
г)	Продукти (products):
1)	Унікальний ідентифікатор продукту (product_id);
2)	Назва продукту (name);
3)	Опис продукту (description);
4)	Ціна продукту (price);
5)	Мінімальна кількість для поповнення (min_quantity);
⦁	Ідентифікатор постачальника (supplier_id);
7)	URL зображення продукту (image_url).
д)	Замовлення (orders):
1)	Ідентифікатор замовлення (order_id);
2)	Дата замовлення (order_date);
3)	Ідентифікатор постачальника (supplier_id);
4)	Ідентифікатор складу (warehouse_id).
е)	Платежі (payments):
1)	Ідентифікатор платежу (payment_id);
2)	Дата платежу (payment_date);
3)	Сума (amount);
4)	Ідентифікатор користувача (user_id);
5)	Термін дії картки (card_expiry);
6)	CVV-код картки (card_cvv);
7)	Ім'я платника (first_name);
8)	Прізвище платника (last_name);
⦁	Статус платежу (status);
10)	Метод оплати (payment_method).
ж)	Продажі (sales):
1)	Ідентифікатор продажу (sale_id);
2)	Дата продажу (sale_date);
3)	Вартість продажу (sale_cost);
4)	Ідентифікатор користувача (user_id);
5)	Статус продажу (status).
и)	Товари в продажу (sale_product):
1)	Ідентифікатор товару в продажу (sale_product_id);
2)	Ідентифікатор продажу (sale_id);
3)	Ідентифікатор продукту (product_id);
4)	Кількість проданого товару (quantity).
к)	Поповнення запасів (restock_orders):
1)	Ідентифікатор поповнення запасів (restock_order_id);
2)	Ідентифікатор продукту (product_id);
3)	Ідентифікатор складу (warehouse_id);
4)	Кількість замовленого товару (order_quantity);
5)	Дата замовлення (order_date);
6)	Статус поповнення (status).
л)	RFID-сканування (rfid_readings):
1)	Ідентифікатор сканування (reading_id);
2)	Ідентифікатор продукту (product_id);
3)	Ідентифікатор складу (warehouse_id);
4)	Кількість товару (quantity);
5)	Час сканування (reading_timestamp);
6)	Ідентифікатор мітки (tag_id).
м)	Кошик покупок (shopping_cart):
1)	Ідентифікатор запису (id);
2)	Ідентифікатор користувача (user_id);
3)	Ідентифікатор продукту (product_id);
4)	Кількість доданого товару (amount);
5)	Дата створення запису (created_at);
6)	Дата оновлення запису (updated_at).
н)	Постачальники (suppliers):
1)	Ідентифікатор постачальника (supplier_id);
2)	Ім'я постачальника (first_name);
3)	Прізвище постачальника (last_name);
4)	Електронна пошта постачальника (email);
5)	Номер телефону постачальника (phone_number).
п)	Мітки (tags):
1)	Ідентифікатор мітки (tag_id);
2)	Ідентифікатор продукту (product_id);
3)	RFID-код (rfid_code).
с)	Транзакції (transactions):
1)	Ідентифікатор транзакції (transaction_id);
2)	Сума транзакції (amount);
3)	Дата створення транзакції (created_at);
4)	Ідентифікатор користувача (user_id);
5)	Ідентифікатор складу (warehouse_id);
6)	Прізвище платника (last_name);
7)	Номер картки (card_number);
⦁	Термін дії картки (card_expiry);
⦁	Статус транзакції (status);
10) CVV-код картки (card_cvv).
т)	Склади (warehouses):
1)	Ідентифікатор складу (warehouse_id);
2)	Ідентифікатор користувача (user_id);
3)	Розташування складу (location).
Ця структура даних є основою для розробки серверної частини, яка буде реалізована за допомогою NestJS.
Перед розробкою серверної частини даної системи важливо детально визначити ролі користувачів і функціональність, яку кожна з них матиме. Розглянемо основні ролі та їх можливості.
Адміністратор системи має найширші повноваження. Його основні завдання включають управління користувачами, продуктами та замовленнями. Адміністратор може створювати нових користувачів, редагувати їх дані, призначати ролі і видаляти облікові записи. Крім того, він управляє продуктами, додаючи нові або редагуючи існуючі записи, а також обробляє замовлення, контролюючи їх виконання. Адміністратор має доступ до системних налаштувань, що допомагає підтримувати ефективну роботу системи.
Менеджер складу фокусується на управлінні товарами. Він має можливість переглядати поточний стан запасів і перелік товарів на складі. Менеджер також обробляє замовлення, що надходять, і здійснює коригування при необхідності, забезпечуючи ефективну роботу складу.
Користувач системи отримує доступ до основних функцій, таких як перегляд продуктів, додавання їх до кошика та оформлення замовлень. Він може переглядати деталі продуктів, ціни та наявність, а також управляти своїм профілем, редагуючи особисті дані і налаштування. Користувач також має доступ до історії своїх покупок, що допомагає відстежувати витрати і зроблені замовлення.
Неавторизований користувач має обмежений доступ, що дозволяє йому ознайомитися з основною інформацією про систему, такими як функціональні можливості і переваги. Цей користувач може зареєструватися або увійти до системи, щоб отримати розширені можливості, включаючи доступ до всіх функцій.
На рис. 3.3 представлена діаграма сценаріїв використання (Use Case Diagram), що відображає взаємодію різних ролей користувачів з основними функціями системи. Діаграма показує, як авторизація/реєстрація є початковим етапом для всіх користувачів, після чого вони можуть виконувати інші дії, такі як перегляд власного профілю, замовлення товарів, управління складом та адміністрування системи.
Загалом, розробка серверної частини системи передбачає створення API для управління користувачами, продуктами і замовленнями, забезпечення безпеки через аутентифікацію та авторизацію, а також реалізацію моніторингу та резервного копіювання даних для підтримки стабільної роботи системи. Це дозволить забезпечити ефективне управління даними та функціоналом, відповідаючи потребам всіх ролей у системі.
Архітектура системи включає декілька ключових компонентів, які взаємодіють між собою для забезпечення повного циклу збору, обробки та відображення даних. В основі системи лежать IoT пристрої на базі мікроконтролерів Arduino з використанням бездротового модуля E32, які програмуються на мові C++. Ці пристрої збирають дані та передають їх до серверної частини, яка реалізована на платформі NestJS. Серверна частина відповідає за обробку даних, управління запитами та забезпечення зв'язку з іншими компонентами системи через API.
З іншого боку, клієнтська частина, побудована на React, забезпечує користувачам інтерфейс для взаємодії із системою, відображаючи отримані дані та дозволяючи керувати пристроями або іншими функціями. 
Користувачі також можуть отримувати доступ до функціоналу системи через браузер на своїх ПК або мобільних пристроях, що забезпечує гнучкість і зручність у використанні. Уся ця інфраструктура працює як єдина система, де кожен компонент відіграє свою важливу роль у забезпеченні безперебійного збору, обробки та доступу до даних (див. рис. 3.2).

 
Рисунок 3.2 – Діаграма розгортання (Deployment Diagram)

 
Рисунок 3.3 - UML діаграма прецедентів (Use Case Diagram)


 
Рисунок 3.4 - UML діаграма діяльності (Activity Diagram)

	Всі ці функції взаємопов'язані, що відображається на діаграмі, і деякі з них включають або розширюють інші, забезпечуючи повну функціональність системи.


3.2 Проєктування IoT-частини системи

	
E32 RFID зчитувач призначений для моніторингу товарів, що надходять на склад або знімаються з нього. Пристрій має два основних режими роботи: додавання товарів до складу та зняття товарів зі складу.
Коли RFID зчитувач зчитує тег товару, він надсилає дані на сервер. Ці дані включають інформацію про ідентифікатор товару і режим, у якому працює зчитувач (додавання чи зняття). Сервер отримує ці дані, обробляє їх і відповідно оновлює інформацію в базі даних складу.
Якщо товар надходить на склад, сервер оновлює записи в базі даних, збільшуючи кількість одиниць товару. Якщо товар знімається зі складу, сервер зменшує кількість одиниць товару у базі даних.
Інтерфейс користувача підключений до сервера і дозволяє переглядати актуальну інформацію про запаси на складі, а також управляти процесами, пов'язаними з обробкою даних від RFID зчитувача.
Таким чином, система забезпечує автоматизоване управління запасами на складі за допомогою RFID технологій, спрощуючи відстеження товарів та підтримку точності обліку.
 
Рисунок 3.5 - UML діаграма прецедентів IoT (Use Case Diagram)




3.3 Проєктування клієнтської частини системи


Система включає в себе три ролі користувачів, це Адміністратор, звичайний Користувач та Менеджер складу. Кожен з цих користувачів має доступ до базових функцій системи, а саме перегляду та зміни профілю, пощуку товарів та додавання їх у свій кошик, після чого створення замовленння. В свою чергу неавторизований користувач, що не має ролі, має доступ лише до головної сторінки та перегляду списку товарів.
Адміністратор має особливий доступ до всієї системи та до панелі адміністратора, з якої може керувати всіма необхідними даними, профілями користувачів та складами.
Менеджер складу це користувач, котрий регулярно платить за інтеграцію системи у свій склад задля автоматизації та економії робочої сили часу та додаткових затрат.
Опишемо компоненти клієнтської чатини:
а) Реєстрації
		1) Адміністратор має доступ до створення нового користувача в системі;
		2) Користувач може зареєструвати новий профіль ввівши необхідні дані, а саме свій нікнейм, пошту, пароль та підтвердження паролю. Якщо всі дані були введені коректно та пройшли перевірку. Система створить нового користувача.
б) Авторизація
		1) Користувач авторизується за допомогою вводу свого нікнейму та паролю. Якщо дані проходять перевірку, такий користувач дійсно існує в системі та пароль співпадає, то користувач опинеться на сторінці свого профілю.
Розглянемо функціональність програмної системи:
а) Функціонал для Неавторизованого користувача:
		1) перегляд головної сторінки;
		2) перегляд інформації для бізнесу та покупців;
		3) можливість зареєструватися або авторизуватися.
б) Функціонал для звичайного Користувача:
		1) редагувати власний профіль;
		2) додавати товари в кошик;
		3) редагувати товари в кошик;
		4) видаляти товари з  кошику
		5) створювати замовлення товарів з кошику
		6) підвищити рівень доступу та придбати підписку для інтеграції системи в сій склад.
в) Функціонал для Адміністратора:
		1) всі функції, що доступні звичайному користувачу;
		2) адміністрування системи.
г) Менеджер складу:
		1) всі функції, що доступні звичайному користувачу;
		2) керування власним складом;
		3) додавання нових продуктів та постачальників до власного складу ;
		4) редагування продуктів та їх постачальників на власному складі;
		5) видалення продуктів із власного складу і відповідно з усієї системи.
Розглянемо кожну функцію системи на клієнтській стороні:
 
Рисунок 3.7 Головна сторінка

 
Рисунок 3.8 – Сторінка «Для Бізнесу»
 
Рисунок 3.9 – Сторінка «Для Клієнстів»
 
Рисунок 3.10 – Сторінка Реєстрації



Сторінка реєстрації (див.рис. 3.10) включає в себе наступні компоненти:
Форма реєстрації (Register Form):
а)	Заголовок: "Register" – розташований зверху форми, з центруванням тексту.
б)	Поля вводу:
1) User Name: Текстове поле для введення імені користувача.
2) Email: Текстове поле для введення електронної пошти.
3) Password: Поле для введення пароля.
4) Confirm Password: Поле для підтвердження пароля.
в) Повідомлення: Під полями форми є текст, що повідомляє: "You will be registered with the User role."
г) Кнопка:
⦁	Register: Стильна кнопка для подачі форми. Кнопка має зелений колір з білим текстом.
д) Посилання: Під формою є текст з посиланням "Already have an account? Log in here" для перенаправлення на сторінку входу.
 
Рисунок 3.11 – Сторінка Авторизації
Сторінка Авторизації (див. рис. 3.11) включає наступні компоненти:
а) Заговловок “Login” – розташований зверху форми, з центруванням тексту.
б)	Поля вводу:
1) User Name: Текстове поле для введення імені користувача.
3) Password: Поле для введення пароля.
в) Кнопка:
⦁	Register: Стильна кнопка для подачі форми. Кнопка має зелений колір з білим текстом.
г) Посилання: Під формою є текст з посиланням " Don't have an account yet?Register here" для перенаправлення на сторінку реєстрації.

 
Рисунок 3.12 – Сторінка профілю користувача




Основний блок профілю (див. рис. 3.12):
а) Аватар: Велике коло з аватаром користувача (стилізоване зображення людини).
1)	Кнопка зміни аватара: Під аватаром розміщена зелена кнопка "Change Avatar".
2)	Інформація про користувача:
- Username: Показано значення імені користувача.
- Email: Показано адресу електронної пошти.
- Created At: Відображається дата і час створення профілю.
- Role: Показано роль користувача (в даному випадку "User").
б) Панель оновлення плану (Upgrade Plan Panel):
1) Текст: "Upgrade Your Plan!" із пропозицією підключити бізнес (склад) до системи та автоматизувати процеси.
2) Кнопка: Синя кнопка "Upgrade Now" для переходу до оновлення плану.
в) Фонова секція:
1) Фон: Темний фон із кольоровими елементами, що додають контраст та цікаву графічну складову до загального вигляду сторінки.
	Ця сторінка профілю користувача містить основну інформацію про користувача і дозволяє змінити аватар або оновити план підписки. Кожен компонент можна реалізувати як окремий React-компонент для зручності та підтримки.



 
Рисунок 3.13 – Сторінка каталогу продуктів
	Зображення демонструє сторінку, яка є каталогом продуктів для веб-додатку "StockManager". Основні компоненти цієї сторінки:
	а) Основний заголовок сторінки:
	1) Великий заголовок посередині сторінки з текстом "Products".
	б) Карточки продуктів:
	1) На сторінці представлено кілька карток продуктів, кожна з яких включає такі елементи:
	- Зображення продукту у верхній частині картки.
	- Назва продукту у вигляді заголовка, виділена жирним шрифтом.
	- Опис продукту під назвою, короткий текстовий опис.
	- Інформація про постачальника з префіксом "Supplier: ".
	- Інформація про склад з префіксом "Warehouse: ".
	- Кількість товару на складі (Quantity).
	 - Кнопка "Add to Cart" внизу кожної картки, яка дозволяє додати продукт до кошика. Кнопка має оранжевий фон і білий текст.
	Ця сторінка використовується для перегляду продуктів, що знаходяться в каталозі, з можливістю додавання їх до кошика для подальшої покупки.
 
Рисунок 3.14 – Сторінка Кошику
	Сторінка Кошика (див.рис. 3.14) у веб-додатку "StockManager" має наступні основні компоненти:
а) Заголовок сайту та навігаційна панель:
1) Логотип з назвою "StockManager" зліва.
2) Меню навігації зверху з розділами: "Home", "For Business", "For 3) Customers", "Products", "Cart", "Order History", "Profile".
4) Значки прапорів (для перемикання мов) та кнопка "Log Out" праворуч. Активний розділ "Cart" виділено.
б) Основний заголовок сторінки:
1) Великий заголовок посередині сторінки з текстом "Shopping Cart".
	в) Таблиця товарів у кошику:
1) Ліва частина сторінки містить таблицю товарів, що знаходяться в кошику. Вона складається з наступних колонок:
- Product Details (Деталі продукту): включає зображення продукту, назву, короткий опис та посилання для видалення товару з кошика ("Remove").
- Quantity (Кількість): користувач може змінювати кількість товару за допомогою кнопок "+" та "-".
- Price (Ціна): відображає ціну за одиницю товару.
- Total (Всього): показує загальну вартість товару (ціна помножена на кількість).
г) Кнопка для продовження покупок:
1) Під таблицею товарів розміщена посилання "Continue Shopping" (Продовжити покупки), яке повертає користувача до каталогу продуктів.
д) Секція "Order Summary" (Підсумок замовлення):
	1) Права частина сторінки містить блок підсумку замовлення, де відображено:
- Items (Товари): загальна вартість товарів у кошику.
- Shipping (Доставка): опція вибору типу доставки (наприклад, "Standard Delivery - $5").
- Total Cost (Загальна вартість): сума вартості товарів та доставки.
2) Нижче розміщена кнопка "Checkout" (Оформити замовлення) для завершення покупки.
	Ця сторінка призначена для перегляду та управління товарами в кошику, а також для переходу до оформлення замовлення.

 
Рисунок 3.15 – Сторінка Історії замовлень
Сторінка Історії замовлень (див.рис. 3.15)містить наступні компоненти:
а)Розділ з очікуваними замовленнями:
	2) Дата, коли було виставлено рахунок за замовлення.
3) Деталі замовлення (у поточному вигляді відсутні).
4) Статус замовлення, який також наразі відсутній.
	б) Розділ минулих замовлень:
1) Дата, коли було виставлено рахунок за замовлення.
2) Деталі замовлення, наприклад, назви продуктів.
3) Статус замовлення, відображений як "Delivered" зеленим кольором.

 
3.16 - Сторінка Оплати замолення
	Сторінка Оплати замовлення (див.рис. 3.16) має такі компоненти:
	 а) Заголовок сторінки: У центрі відображено заголовок "Payment page" великим шрифтом.
	б) Форма оплати:
	1) Сума: Введене поле з відображенням суми "$671.00".
	2) Номер картки: Текстове поле для введення номера картки.
	3) Дата закінчення терміну дії картки: Поле для введення дати закінчення терміну дії картки.
	4) CVV картки: Поле для введення CVV коду картки.
	5) Ім'я: Поле для введення імені власника картки.
	6) Прізвище: Поле для введення прізвища власника картки.
	в) Кнопки:
	1) Confirm payment: Зелена кнопка для підтвердження оплати.
		2) Cancel: Кнопка для скасування.



 
Рисунок 3.17 – Сторінка керування складом
	Сторінка керування складом містить наступні компоненти:
	  а) Заголовок сторінки: У центрі відображено заголовок "Warehouse Management" великим шрифтом.
	  б) Карточки продуктів:
1) Зображення продукту.
2) Назва продукту: Наприклад, "Product 2", "Product D", "Product C".
3) Опис продукту: Короткий опис продукту.
4) Постачальник: Вказується постачальник продукту.
5) Мінімальна кількість: Вказано мінімальну кількість продукту, яка має бути на складі.
6) Кількість на складі: Відображає актуальну кількість продукту на складі.
7) Ціна: Вартість продукту.
8) Кнопка "Edit Product": Помаранчева кнопка для редагування інформації про продукт.
	  в) Кнопка "Add New Product": Велика чорна карточка з помаранчевим плюсом і написом "Add New Product" зліва для додавання нового продукту.

 
Рисунок 3.18 – Сторінка додавання нового товару на склад

	Сторінка з формою для додавання нового продукту (див.рис. 3.18) складається з кількох компонентів, зокрема:
а)Заголовок сторінки: Великий текст у верхній частині, що говорить "Add Product" ("Додати продукт").
	б) Форма додавання продукту:
1) Поле "Name": Текстове поле для введення назви продукту. Позначено червоною зірочкою, що вказує на обов'язкове заповнення.
2) Поле "Description": Текстова область для введення опису продукту.
3) Поле "Price": Текстове поле для введення ціни продукту. Також позначено червоною зірочкою, що вказує на обов'язкове заповнення.
4)Поле "Minimum Quantity": Текстове поле для введення мінімальної кількості продукту.
в) Розділ інформації про постачальника (Supplier Information):
1) Поле "First Name": Текстове поле для введення імені постачальника.
2) Поле "Last Name": Текстове поле для введення прізвища постачальника.
3) Поле "Email": Текстове поле для введення електронної пошти постачальника.
4) Поле "Phone Number": Текстове поле для введення номера телефону постачальника.
г) Кнопки дій:
	1) Кнопка "Save": Кнопка для збереження введених даних та додавання продукту.
2) Кнопка "Cancel": Кнопка для скасування дій та повернення до попередньої сторінки або очищення форми.
	Форма має темний фон з білими текстовими полями та оранжевими кнопками для дій, що створює чіткий контраст.
 
Рисунок 3.19 – Сторінка Редагування товару на складі
Сторінка редагування продукту (див.рис. 3.19) має такі компоненти :
	а) Зображення продукту:
1) Ліворуч розміщено зображення продукту (шампуню). Під зображенням знаходиться кнопка "Change Image" ("Змінити зображення"), яка дозволяє змінити зображення продукту.
б) Форма редагування продукту:
	1) Поле "Name": Текстове поле, що містить назву продукту ("Product 2").
2) Поле "Description": Текстова область, яка містить опис продукту ("Description for Product 2").
3) Поле "Price": Текстове поле для ціни продукту (75,25).
	в) Розділ інформації про постачальника (Supplier Information):
	1) Поле "First Name": Текстове поле, що містить ім'я постачальника ("Djohn").
2) Поле "Last Name": Текстове поле, що містить прізвище постачальника ("Doe").
3) Поле "Email": Текстове поле для електронної пошти постачальника ("djohndoe@example.com").
4) Поле "Phone Number": Текстове поле для номера телефону постачальника ("+38 077 77 93 94").
г)	Кнопки дій:
1) Кнопка "Save": Зелена кнопка для збереження змін продукту.
2) Кнопка "Cancel": Жовта кнопка для скасування дій.
3) Кнопка "Delete Product": Червона кнопка для видалення продукту.
	Форма на темному фоні з яскравими кольоровими кнопками для різних дій, що створює зручний інтерфейс для редагування продукту
 
Рисунок 3.20 – Панель адміністрування






⦁	РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ
⦁	 Архітектура та розробка серверної частини


	У процесі реалізації серверної частини програмної системи було використано фреймворк NestJS. Це прогресивний фреймворк для Node.js, який дозволяє створювати надійні, масштабовані та ефективні серверні додатки. NestJS базується на TypeScript і використовує концепцію декораторів та інверсії контролю, що дозволяє писати чистий та підтримуваний код.


⦁	Архітектура серверної частини


	Архітектура серверної частини була побудована навколо концепції модульності, що є однією з основних особливостей NestJS. Система складається з декількох основних компонентів:
	а) Контролери (Controllers): Контролери відповідають за обробку HTTP-запитів, які надходять до серверу. Вони отримують запити від клієнтів, викликають необхідні сервіси для обробки даних і повертають відповідь. У кожному контролері визначено маршрути, які відповідають за конкретні дії, такі як створення, оновлення, видалення чи отримання даних.
	б) Сервіси (Services): Сервіси виконують основну логіку додатка. Вони обробляють дані, працюють з базою даних і забезпечують виконання бізнес-логіки. Сервіси є незалежними і можуть бути легко протестовані окремо від інших компонентів системи.
	в) Сутності (Entities): Сутності визначають структуру даних у додатку. Вони використовуються для взаємодії з базою даних і визначають, як дані зберігаються і обробляються. Сутності часто відображаються на таблиці в базі даних і включають поля, які відповідають колонкам таблиці.
	г) DTO (Data Transfer Objects): DTO використовуються для передачі даних між клієнтом і сервером. У NestJS зазвичай створюються два типи DTO для кожного ресурсу:
⦁	CreateDTO: Використовується для створення нового ресурсу. Він включає всі поля, необхідні для створення об'єкта в базі даних;
2) UpdateDTO: Використовується для оновлення існуючого ресурсу. Він включає тільки ті поля, які можуть бути змінені.
	д) Модулі (Modules): Усі контролери, сервіси та сутності об'єднуються в модулі. Модулі в NestJS дозволяють організувати додаток у незалежні, логічно зв'язані частини. Кожен модуль може імпортувати інші модулі, що дозволяє розділяти логіку додатка на окремі компоненти.


⦁	Процес розробки


	Розробка серверної частини почалася з визначення основних сутностей системи. Для кожної сутності було створено відповідний контролер, сервіс і DTO. Нижче наведено більш детальний опис кожного етапу розробки:
	а) Визначення Сутностей: Спочатку визначається структура даних, які будуть використовуватися в системі. Наприклад, для додатка, що керує продуктами, сутністю буде Product, яка матиме поля id, name, description, price, тощо.
	б) Розробка DTO: Після визначення сутностей створюються DTO, які використовуються для передачі даних. Наприклад, для створення нового продукту створюється клас CreateProductDTO, який містить всі обов'язкові поля для створення продукту.
	в) Розробка Сервісів: Далі створюються сервіси, які обробляють логіку додатка. Сервіси взаємодіють з базою даних через репозиторії або ORM (Object-Relational Mapping) бібліотеки, такі як TypeORM або Sequelize. Наприклад, сервіс ProductService може містити методи для створення, отримання, оновлення та видалення продуктів.
	г) Розробка Контролерів: Після створення сервісів, розробляються контролери, які обробляють HTTP-запити. Контролери викликають відповідні методи сервісів і повертають результати клієнту. Наприклад, контролер ProductController буде містити методи для обробки POST-запитів на створення продукту, GET-запитів на отримання списку продуктів тощо.
	д) Об'єднання в Модулі: На завершальному етапі всі сервіси та контролери об'єднуються в модулі. Кожен модуль імпортується в основний модуль додатка (наприклад, AppModule), що дозволяє використовувати всі його компоненти в додатку.


	4.1.3 Технології та інструменти


	Для реалізації серверної частини було використано кілька важливих технологій та інструментів:NestJS: 
	а) Основний фреймворк для створення серверного додатка. Його модульна структура, підтримка TypeScript і можливість інтеграції з іншими бібліотеками роблять його ідеальним вибором для розробки масштабованих додатків.
	б) TypeORM: ORM, яка використовується для роботи з базою даних. Вона дозволяє взаємодіяти з базою даних за допомогою об'єктів TypeScript, що значно спрощує роботу з даними.
	в) Swagger: Інструмент для автоматичної генерації документації API. Використання Swagger дозволяє автоматично створювати документацію для всіх кінцевих точок API, що значно спрощує роботу з ним.
	Результатом реалізації серверної частини є гнучка, масштабована та легко підтримувана система, яка відповідає всім вимогам проекту. Завдяки використанню сучасних технологій і підходів, вдалося досягти високої продуктивності та надійності додатка.


	4.2 Сервіс управління поповненням запасів


	Одним із ключових компонентів серверної частини є сервіс управління поповненням запасів (див. розід А1 у додатку А), який автоматизує процес підтримки достатнього рівня запасів на складах. Цей сервіс, написаний на основі фреймворку NestJS, інтегрує кілька основних технологій і використовує комплексний підхід до управління запасами, забезпечуючи своєчасне поповнення товарів та підтримку їх на складі на відповідному рівні.


	4.2.1 Основні завдання сервісу


	Головна мета сервісу управління поповненням запасів полягає в автоматизації процесу відстеження кількості товарів на складах і ініціації процесу поповнення, коли запаси певного товару падають нижче мінімально допустимого рівня. Це дозволяє уникнути ситуацій, коли товари відсутні на складі, що, у свою чергу, може вплинути на ефективність бізнесу і задоволеність клієнтів.
	Сервіс має такі основні завдання:
	а)Моніторинг запасів (див. рядок 30, розділ А1 у додатку А): Регулярно перевіряє рівень запасів кожного товару на складі і порівнює його з мінімально необхідним рівнем, визначеним у системі.
	б) Ініціація поповнення: Якщо рівень запасів певного товару падає нижче мінімального рівня, сервіс автоматично створює запит на поповнення товару (Restock Order).
	в) Автоматичне створення замовленя (див. рядок 42, розділ А1 у додатку А): Сервіс створює замовлення на поповнення запасів, яке містить інформацію про товар, склад, кількість, яку потрібно поповнити, та статус замовлення.
	г) Логування та сповіщення (див. рядок 12, розділ А1 у додатку А): Важливою частиною роботи сервісу є ведення логів про всі дії, що виконуються, а також сповіщення відповідальних осіб про створення нових замовлень або можливі проблеми в процесі поповнення.


⦁	Технологічний стек і компоненти


	Сервіс управління поповненням запасів складається з кількох ключових компонентів, кожен з яких виконує свою специфічну функцію в системі.
	а) Cron-завдання: Основою автоматизації процесу є регулярні завдання (Cron-завдання), які виконуються у визначений час. В даному сервісі використовується декоратор @Cron із бібліотеки @nestjs/schedule, який дозволяє виконувати перевірку рівня запасів на складах у певний час кожного дня (див. рядок 23, розділ А1 у додатку А).
	б)Репозиторії (Repositories): Репозиторії в даному сервісі використовуються для взаємодії з базою даних. Використовуючи @InjectRepository, сервіс отримує доступ до таблиць бази даних, таких як Inventory (запаси), Product (товари) та RestockOrder (замовлення на поповнення) (див. рядки 15-20, розділ А1 у додатку А).
	в) Логування: Використання класу Logger з NestJS дозволяє сервісу записувати інформацію про виконані дії та можливі помилки, що можуть виникати під час процесу перевірки та поповнення запасів. Це спрощує відстеження роботи системи та вирішення можливих проблем (див. рядки 12, 29, 34, 36, 42, 52, розділ А1 у додатку А).
	г) Інтерфейси та декоратори: NestJS активно використовує інтерфейси та декоратори для створення зрозумілої та структурованої архітектури додатка. Декоратор @Injectable() дозволяє зробити сервіс доступним для ін'єкції в інші компоненти додатка, забезпечуючи тим самим легку інтеграцію і повторне використання коду (див. рядок 10, розділ А1 у додатку А).

⦁	Опис основних процесів


	Процес управління поповненням запасів складається з кількох кроків:
	а) Періодична перевірка рівня запасів: Щодня, у визначений час, виконується завдання handleCron, яке перевіряє поточний рівень запасів на всіх складах. Це завдання отримує всі записи про запаси з бази даних і викликає метод checkAndRestock, який аналізує, чи є необхідність у поповненні запасів.
	б) Аналіз рівня запасів і створення замовлень: Якщо запаси певного товару нижчі за встановлений мінімум, сервіс створює новий запис у таблиці RestockOrder, який містить інформацію про товар, склад, необхідну кількість для поповнення та статус замовлення. Цей процес автоматизовано і не вимагає втручання користувача.
	в) Виконання замовлень на поповнення: Після створення замовлення на поповнення, воно переходить у статус "pending" (очікується). Наступний етап — це його виконання, яке може відбуватися автоматично через RFID-сервіс або вручну, залежно від логістичних процесів компанії.
	г)Оновлення статусу замовлень: Після того як запаси були поповнені, сервіс оновлює статус відповідного замовлення на "replenished" (поповнено).
	Це дозволяє тримати актуальну інформацію про стан запасів і завершені замовлення.





	4.3 Архітектура та розробка IoT частини


	У розділі "Архітектура та розробка IoT частини" розглянемо ключові компоненти, які забезпечують функціонування RFID-системи та взаємодію з сервером.
	а)RFID Reader:
1)  Основний клас RFIDReader (див. рядки 7-40, секція A.4 в Додатку A) відповідає за зчитування RFID-міток. Він використовує бібліотеку MFRC522 для взаємодії з RFID-зчитувачем. Ініціалізація відбувається в методі init() (див. рядки 19-23, секція A.4 в Додатку A), який налаштовує SPI-з'єднання та ініціалізує RFID-зчитувач. Метод read() (див. рядки 25-38, секція A.4 в Додатку A) зчитує унікальний ідентифікатор RFID-мітки та повертає його у вигляді рядка.
б)Режим розробки (Dev Mode):
1) У режимі розробки використовується клас DevRFIDReader (див. рядки 7-35, секція A.4 в Додатку A), який емулює зчитування RFID-міток, використовуючи список заздалегідь визначених значень. Це дозволяє тестувати систему без реального RFID-зчитувача. Перемикання між реальним і тестовим зчитувачем відбувається в залежності від того, чи увімкнено DEV_MODE (див. рядки 8-14, секція A.7 в Додатку A).
в) Конфігурація:
1) У файлі config.h (див. рядки ії 1-33, секція A.6 в Додатку A) визначаються основні параметри, такі як налаштування Wi-Fi, конфігурація пристрою, та URL-адреси для взаємодії з сервером. Ці параметри використовуються в основному файлі програми для налаштування підключення та обміну даними з сервером (див. рядки 45-52, секція A.7 в Додатку A).
г) Взаємодія з сервером:
1) Метод sendRequest() (див. рядки 18-35, секція A.7 в Додатку A) відповідає за відправку запитів на сервер. Він формує URL-адресу, додаючи до неї ID пристрою, токен автентифікації та зчитаний RFID, після чого надсилає HTTP POST-запит на відповідний ендпоінт сервера.
д) Логіка роботи:
1) Головний цикл програми розташований у функції loop() (див. рядки 57-71, секція A.7 в Додатку A). Він постійно зчитує значення RFID-мітки та перевіряє стан кнопок для збільшення або зменшення значення на сервері. Якщо кнопка натиснута, викликається метод sendRequest() для відправки відповідного запиту на сервер.
	Ця структура дозволяє створити гнучку та надійну систему для зчитування RFID-міток і взаємодії з віддаленим сервером, з можливістю тестування в режимі розробки.


4.4 Архітектура та розробка web частини


	Архітектура та розробка веб-частини цього проєкту здійснювалася за допомогою сучасного фреймворку React, який є одним із найбільш популярних інструментів для створення динамічних та інтерфейсів, що швидко реагують. Вибір React був обґрунтований його гнучкістю, та продуктивністю, що надає широкий спектр можливостей для розробки веб-застосунків різного рівня складності.У структурі проєкту особливу увагу було приділено логічній організації коду та чіткому розподілу функціональності між різними модулями, що значно полегшує підтримку та розширення функціоналу в майбутньому. Проєкт структурований таким чином, що кожен аспект функціональності має своє місце, що сприяє чіткому розумінню та простоті навігації по коду.
	В папці pages зберігаються всі сторінки проєкту, кожна з яких відповідає за конкретну частину інтерфейсу. Це забезпечує високу модульність проєкту, адже кожна сторінка має свій власний CSS-файл для стилізації, що дозволяє легко вносити зміни в дизайн без ризику порушити загальний стиль сайту. 	Такий підхід також полегшує налагодження, адже можна швидко знайти та виправити помилки, що виникають на окремих сторінках.
	Важливою частиною архітектури є папка components, де зберігаються всі компоненти, що повторно використовуються на різних сторінках. Це дозволяє ефективно використовувати код, оскільки компоненти можуть бути створені один раз і використовуватися в різних частинах програми без необхідності дублювання коду. Крім того, використання компонентів робить код більш читабельним та логічно організованим, що значно спрощує його підтримку.
	Не менш важливою є папка assets, яка містить усі необхідні зображення та інші медіафайли. Така організація дозволяє чітко розподілити ресурси та забезпечує легкий доступ до них під час розробки, що знижує ризик помилок та покращує ефективність роботи над проєктом.
	Окремої уваги заслуговує підхід до інтернаціоналізації сайту. В папці i18n зберігається файл i18n.js, який відповідає за налаштування інтернаціоналізації. Також в цій папці розміщені файли en.js та ua.js, які містять відповідні переклади для англійської та української мов. Така структура дозволяє легко додавати нові мови або редагувати існуючі переклади, що робить сайт доступним для ширшої аудиторії.
	Загалом використання React забезпечило не лише високу продуктивність та гнучкість, але й сприяло створенню чистого, модульного коду, який легко підтримувати та розширювати. Цей підхід робить проєкт стійким до змін та відкритим до масштабування, що є надзвичайно важливим у сучасному динамічному світі веб-розробки.


















ВИСНОВКИ


	У цьому проєкті була розроблена комплексна програмна система, яка об'єднує кілька ключових компонентів для управління складськими запасами. Основна мета полягала в створенні інтегрованого рішення, яке автоматизує процеси контролю, відстеження та поповнення товарних запасів, забезпечуючи ефективне зберігання та швидкий доступ до даних.
	Розробка серверної частини базувалася на платформі NestJS, що дозволило створити модульну та добре структуровану архітектуру. Кожен сервіс був організований як окремий модуль, який включає контролери, сутності та DTO, що сприяло чіткому розподілу обов’язків і спростило впровадження нових функцій. Такий підхід забезпечив легкість масштабування та підтримки системи.
	Особливий акцент було зроблено на розробці IoT компонента системи, який використовує RFID-рідери для взаємодії з фізичними об'єктами. Використовуючи бібліотеки Arduino, система отримала можливість читати дані з RFID-міток та передавати їх на центральний сервер для подальшої обробки. Завдяки спеціально розробленим класам, таким як RFIDReader і DevRFIDReader, була реалізована можливість як симуляції, так і реального читання даних, що значно полегшило процес тестування та забезпечило гнучкість у розробці.
	Веб-інтерфейс проєкту, створений з використанням React, відрізняється чіткою архітектурою, що спрощує підтримку і розширення функціональних можливостей. Всі сторінки та компоненти розподілені по відповідних папках, що забезпечує легкість у навігації та розробці. Додатково, система підтримує інтернаціоналізацію, що дозволяє легко адаптувати інтерфейс під різні мовні аудиторії, забезпечуючи зручність користування для всіх категорій користувачів.
	В результаті реалізації проєкту було створено надійну, масштабовану та зручну у використанні систему, що об'єднує серверну частину, IoT-пристрої та веб-інтерфейс у єдиний продукт. Це дозволяє ефективно керувати запасами, запобігати дефіциту товарів та підвищувати продуктивність операційних процесів. Таким чином, розроблена система є важливим інструментом для автоматизації складських операцій, що забезпечує високу ефективність, надійність і простоту в експлуатації.


















ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


	1.  NestJS. (2023). Official Documentation. URL: https://docs.nestjs.com. (дата звернення: 15.07.2024)
	2.  React. (2023). React Documentation. URL: https://reactjs.org/docs/getting-started.html. (дата звернення: 01.08.2024)
	3.  Arduino. (2023). Arduino Reference. URL: https://www.arduino.cc/reference/en/. (дата звернення: 18.08.2024)
	4.  TypeORM. (2023). TypeORM Documentation. URL: https://typeorm.io/#/. (дата звернення: 18.08.2024)
	5.  SPI Library. (2023). Arduino SPI Library Documentation. URL https://www.arduino.cc/en/Reference/SPI. (дата звернення: 21 .08.2024)	6.  Wi-Fi Library for Arduino. (2023). WiFi Library Documentation. URL: https://www.arduino.cc/en/Reference/WiFi. (дата звернення: 23.08.2024)












Додатки
ДОДАТОК А
КОД З ФАЙЛІВ ПРОГРАМИ
А.1 Сервіс управління поповненням запасів, файл  “inventory-management.service.ts”
1. import { Injectable, Logger } from '@nestjs/common';
2. import { InjectRepository } from '@nestjs/typeorm';
3. import { Repository } from 'typeorm';
4. import { Warehouse } from 'src/modules/warehouses/warehouse.entity';
5. import { Inventory } from 'src/modules/inventory/inventory.entity';
6. import { Product } from 'src/modules/products/product.entity';
7. import { RestockOrder } from 'src/modules/restock_orders/restock_order.entity';
8. import { Cron } from '@nestjs/schedule';
9. 
10. @Injectable()
11. export class InventoryManagementService {
12.   private readonly logger = new Logger(InventoryManagementService.name);
13. 
14.   constructor(
15.     @InjectRepository(Inventory)
16.     private inventoryRepository: Repository<Inventory>,
17.     @InjectRepository(Product)
18.     private productsRepository: Repository<Product>,
19.     @InjectRepository(RestockOrder)
20.     private restockOrdersRepository: Repository<RestockOrder>,
21.   ) {}
22. 
23.   @Cron('50 0 * * *') 
24.   async handleCron() {
25.     await this.checkAndRestock();
26.   }
27. 
28.   async checkAndRestock(): Promise<void> {
29.     this.logger.debug('Fetching inventories...');
30.     const inventories = await this.inventoryRepository.find({ relations: ['product', 'warehouse'] });
31.     
32.     for (const inventory of inventories) {
33.       const product = inventory.product;
34.       this.logger.debug(`Checking product ${product.name} with quantity ${inventory.quantity} and min_quantity ${product.min_quantity}`);
35.       if (inventory.quantity < product.min_quantity) {
36.         this.logger.debug(`Product ${product.name} is below min quantity. Initiating restock...`);
37.         await this.restockProduct(product, inventory.warehouse, product.min_quantity - inventory.quantity);
38.       }
39.     }
40.   }
41. 
42.   private async restockProduct(product: Product, warehouse: Warehouse, orderQuantity: number): Promise<void> {
43.     this.logger.debug(`Creating restock order for product ${product.name} in warehouse ${warehouse.location}`);
44.     const newRestockOrder = this.restockOrdersRepository.create({
45.       product: product,
46.       warehouse: warehouse,
47.       order_quantity: orderQuantity,
48.       order_date: new Date(),
49.       status: 'pending',
50.     });
51.     await this.restockOrdersRepository.save(newRestockOrder);
52.     this.logger.debug(`Restock order created: ${newRestockOrder}`);
53.   }
54. }

А.2 Сервіс управління поповненням запасів, файл  “rfid-reading.service.ts”
1. import { Injectable, Logger } from '@nestjs/common';
2. import { InjectRepository } from '@nestjs/typeorm';
3. import { Repository } from 'typeorm';
4. import { Cron } from '@nestjs/schedule';
5. import { RfidReading } from 'src/modules/rfid_readings/reading.entity';
6. import { Inventory } from 'src/modules/inventory/inventory.entity';
7. import { Tag } from 'src/modules/tags/tag.entity';
8. import { Product } from 'src/modules/products/product.entity';
9. import { Warehouse } from 'src/modules/warehouses/warehouse.entity';
10. import { RestockOrderStatusService } from './restock-order_status.service';
11. import { RestockOrder } from 'src/modules/restock_orders/restock_order.entity';
12. 13. @Injectable()
14. export class RFIDReadingService {
15.   private readonly logger = new Logger(RFIDReadingService.name);
16. 
17.   constructor(
18.     @InjectRepository(RfidReading)
19.     private rfidReadingRepository: Repository<RfidReading>,
20.     @InjectRepository(Inventory)
21.     private inventoryRepository: Repository<Inventory>,
22.     @InjectRepository(Tag)
23.     private tagRepository: Repository<Tag>,
24.     @InjectRepository(Product)
25.     private productRepository: Repository<Product>,
26.     @InjectRepository(Warehouse)
27.     private warehouseRepository: Repository<Warehouse>,
28.     @InjectRepository(RestockOrder) 
29.     private restockOrderRepository: Repository<RestockOrder>,
30.     private restockOrderStatusService: RestockOrderStatusService,
31.   ) {}
32. 
33.   @Cron('51 0 * * *') 
34.   async simulateRfidReadings() {
35.     this.logger.debug('Simulating RFID readings');
36.   
37.     const pendingRestockOrders = await this.restockOrderRepository.find({
38.       where: { status: 'pending' },
39.       relations: ['product', 'warehouse']
40.     });
41.   
42.     if (pendingRestockOrders.length === 0) {
43.       this.logger.debug('No pending restock orders found');
44.     } else {
45.       this.logger.debug(`Found ${pendingRestockOrders.length} pending restock orders`);
46.     }
47.   
48.     for (const order of pendingRestockOrders) {
49.       this.logger.debug(`Creating RFID reading for product ${order.product.product_id} in warehouse ${order.warehouse.warehouse_id}`);
50.       await this.createRfidReading(order.product.product_id, order.warehouse.warehouse_id, order.order_quantity, order.product.product_id);
51.     }
52.   }  
53. 
54.   async createRfidReading(productId: number, warehouseId: number, quantity: number, tagId: number): Promise<void> {
55.     const product = await this.productRepository.findOneBy({ product_id: productId });
56.     const warehouse = await this.warehouseRepository.findOneBy({ warehouse_id: warehouseId });
57.     const tag = await this.tagRepository.findOneBy({ tag_id: tagId });
58.   
59.     if (!product || !warehouse || !tag) {
60.       throw new Error('Product, Warehouse, or Tag not found');
61.     }
62.   
63.     const newReading = this.rfidReadingRepository.create({
64.       product: product,
65.       warehouse: warehouse,
66.       quantity: quantity, 
67.       reading_timestamp: new Date(),
68.       tag: tag,
69.     });
70.   
71.     await this.rfidReadingRepository.save(newReading);
72.     await this.updateInventory(product, warehouse, quantity); 
73.   }  
74. 
75.   private async updateInventory(product: Product, warehouse: Warehouse, orderQuantity: number): Promise<void> {
76.     this.logger.debug(`Updating inventory for product ${product.name} in warehouse ${warehouse.location} with quantity ${orderQuantity}`);
77.     const inventory = await this.inventoryRepository.findOne({
78.       where: { product: { product_id: product.product_id }, warehouse: { warehouse_id: warehouse.warehouse_id } },
79.     });
80.   
81.     if (inventory) {
82.       this.logger.debug(`Existing inventory found. Current quantity: ${inventory.quantity}`);
83.       inventory.quantity += orderQuantity;
84.       await this.inventoryRepository.save(inventory);
85.       this.logger.debug(`Updated inventory quantity: ${inventory.quantity}`);
86.     } else {
87.       this.logger.debug('No existing inventory found. Creating new inventory record.');
88.       const newInventory = this.inventoryRepository.create({
89.         product: product,
90.         warehouse: warehouse,
91.         quantity: orderQuantity,
92.       });
93.       await this.inventoryRepository.save(newInventory);
94.       this.logger.debug('New inventory record created.');
95.     }
96. 
97.     await this.restockOrderStatusService.updateRestockOrders();
98.   }   
99. }
100.

А.3 Сервіс управління поповненням запасів, файл  “restock-order_status.service.ts”
1. import { Injectable, Logger } from '@nestjs/common';
2. import { InjectRepository } from '@nestjs/typeorm';
3. import { Repository } from 'typeorm';
4. import { RestockOrder } from 'src/modules/restock_orders/restock_order.entity';
5. import { Inventory } from 'src/modules/inventory/inventory.entity';
6. 
7. @Injectable()
8. export class RestockOrderStatusService {
9.   private readonly logger = new Logger(RestockOrderStatusService.name);
10. 
11.   constructor(
12.     @InjectRepository(RestockOrder)
13.     private restockOrderRepository: Repository<RestockOrder>,
14.     @InjectRepository(Inventory)
15.     private inventoryRepository: Repository<Inventory>,
16.   ) {}
17. 
18.   async updateRestockOrders(): Promise<void> {
19.     this.logger.debug('Updating restock orders status');
20.   
21.     const restockOrders = await this.restockOrderRepository.find({
22.       where: { status: 'pending' },
23.       relations: ['product', 'warehouse']
24.     });
25.   
26.     for (const order of restockOrders) {
27.       if (!order.product || !order.warehouse) {
28.         this.logger.warn(`Restock order ${order.restock_order_id} is missing product or warehouse`);
29.         continue;
30.       }
31.   
32.       const inventory = await this.inventoryRepository.findOne({
33.         where: { product: { product_id: order.product.product_id }, warehouse: { warehouse_id: order.warehouse.warehouse_id } },
34.       });
35.   
36.       if (inventory && inventory.quantity >= order.order_quantity) {
37.         order.status = 'replenished';
38.         await this.restockOrderRepository.save(order);
39.         this.logger.debug(`Restock order ${order.restock_order_id} updated to replenished`);
40.       }
41.     }
42.   }
43. } 
44.

А.4 IoT частина, файл  “RFIDReader.h”
1. #pragma once
2. #include <Arduino.h>
3. #include <SPI.h>
4. #include <MFRC522.h>
5. #include "BaseRFIDReader.h"
6. 
7. class RFIDReader : public BaseRFIDReader
8. {
9. private:
10.     MFRC522 mfrc522;
11. 
12. public:
13.     RFIDReader(int ssPin, int rstPin) : mfrc522(ssPin, rstPin) {}
14.     ~RFIDReader()
15.     {
16.         SPI.end();
17.     }
18. 
19.     void init()
20.     {
21.         SPI.begin();
22.         mfrc522.PCD_Init();
23.     }
24. 
25.     String read()
26.     {
27.         if (!mfrc522.PICC_IsNewCardPresent() || !mfrc522.PICC_ReadCardSerial())
28.         {
29.             return "";
30.         }
31. 
32.         String uidStr = "";
33.         for (byte i = 0; i < mfrc522.uid.size; i++)
34.         {
35.             uidStr += String(mfrc522.uid.uidByte[i], HEX);
36.         }
37. 
38.         return uidStr;
39.     }
40. };
41. 
42.




А.4 IoT частина, файл  “DevRFIDReader.h”
1. #include <Arduino.h>
2. #include <vector>
3. #include "BaseRFIDReader.h"
4. 
5. using namespace std;
6. 
7. class DevRFIDReader : public BaseRFIDReader
8. {
9. private:
10.     vector<String> rfidList;
11.     int index = 0;
12.     unsigned long lastRead = 0;
13. public:
14.     DevRFIDReader(vector<String> rfidList) : rfidList(rfidList) {}
15. 
16.     void init()
17.     {
18.     }
19. 
20.     String read()
21.     {
22.         if (millis() - lastRead < 1000)
23.         {
24.             return "";
25.         }
26. 
27.         if (index >= rfidList.size())
28.         {
29.             index = 0;
30.         }
31.         
32.         lastRead = millis();
33. 
34.         return rfidList[index++];
35.     }
36. };
37.

А.5 IoT частина, файл  “BaseRFIDReader.h”
1. #pragma once
2. #include <Arduino.h>
3. 
4. class BaseRFIDReader
5. {
6. public:
7.     virtual void init() = 0;
8.     virtual String read() = 0;
9. };
10. 
11.


А.6 IoT частина, файл  “config.h”
1. #pragma one
2. 
3. // Comment this line to disable the debug mode
4. #define DEV_MODE true
5. // Comment this line to disable the serial log
6. #define LOG_SERIAL true
7. 
8. // Buttons pins
9. #define DECREASE_PIN 22
10. #define INCREASE_PIN 23
11. 
12. // RFID Reader pins
13. #define SS_PIN 10
14. #define RST_PIN 9
15. 
16. // WiFi configuration
17. #define WIFI_SSID "Wokwi-GUEST"
18. #define WIFI_PASSWORD ""
19. 
20. // Device configuration
21. #define DEVICE_ID 4
22. #define DEVICE_TOKEN "e4034e62b3600852947ac9f76beabf93-1724538714761"
23. 
24. // Server configuration
25. #define SERVER_URL "http://7.tcp.eu.ngrok.io:17424"
26. #define SERVER_INCREMENT_ENDPOINT "/iot/increase/"
27. #define SERVER_DECREMENT_ENDPOINT "/iot/decrease/"
28. 
29. #ifdef LOG_SERIAL
30. #define LOG(x) Serial.println(x)
31. #else
32. #define LOG(x)
33. #endif
34.

А.7 IoT частина, файл  “config.h”
1. [wokwi]
2. version = 1
3. firmware = '.pio\build\esp32dev\firmware.bin'
4. elf = '.pio\build\esp32dev\firmware.elf'

А.7 IoT частина, файл  “config.h”
1. #include <Arduino.h>
2. #include <WiFi.h>
3. #include <SPI.h>
4. #include <HTTPClient.h>
5. #include "config.h"
6. #include "BaseRFIDReader.h"
7. 
8. #ifdef DEV_MODE
9. #include "DevRFIDReader.h"
10. BaseRFIDReader *rfidReader = new DevRFIDReader({"RFID-VL2IT7Z1M", "RFID-FC72D6E5F2"});
11. #else
12. #include "RFIDReader.h"
13. BaseRFIDReader *rfidReader = new RFIDReader(SS_PIN, RST_PIN);
14. #endif
15. 
16. HTTPClient http;
17. 
18. void sendRequest(String endpoint, String rfid)
19. {
20.   String url = SERVER_URL + endpoint + DEVICE_ID + "?token=" + DEVICE_TOKEN + "&rfid=" + rfid;
21.   LOG(url);
22.   http.begin(url);
23.   http.addHeader("Content-Type", "application/json");
24.   int httpResponseCode = http.POST("");
25.   if (httpResponseCode > 0)
26.   {
27.     String response = http.getString();
28.     LOG(httpResponseCode);
29.     LOG(response);
30.   }
31.   else
32.   {
33.     LOG("Error on sending POST: " + http.errorToString(httpResponseCode));
34.   }
35.   http.end();
36. }
37. 
38. void setup()
39. {
40.   Serial.begin(9600);
41. 
42.   pinMode(INCREASE_PIN, INPUT);
43.   pinMode(DECREASE_PIN, INPUT);
44. 
45.   WiFi.mode(WIFI_STA);
46.   WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
47.   while (WiFi.status() != WL_CONNECTED)
48.   {
49.     delay(1000);
50.     LOG("Connecting to WiFi..");
51.   }
52.   LOG("Connected to the WiFi network");
53. 
54.   rfidReader->init();
55. }
56. 
57. void loop()
58. {
59.   String rfid = rfidReader->read();
60.   if (rfid != "")
61.   {
62.     if (digitalRead(INCREASE_PIN) == HIGH)
63.     {
64.       sendRequest(SERVER_INCREMENT_ENDPOINT, rfid);
65.     }
66.     else if (digitalRead(DECREASE_PIN) == HIGH)
67.     {
68.       sendRequest(SERVER_DECREMENT_ENDPOINT, rfid);
69.     }
70.   }
71. }
72. 
73.

ДОДАТОК Б
ДІАГРАМИ
Б.1 Діаграма ER-модель даних
 
Рисунок 3.1 – ER-модель даних (діаграми) (Entity–Relationship Model). 